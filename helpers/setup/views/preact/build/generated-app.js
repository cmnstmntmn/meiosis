/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../dist/meiosis-setup.js":
/*!*********************************************************************************!*\
  !*** /Users/freddy/fd/git/foxdonut/meiosis/helpers/setup/dist/meiosis-setup.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n  /**\n   * Application object.\n   *\n   * @typedef {Object} app\n   * @property {Object} [initial={}] - an object that represents the initial state.\n   * If not specified, the initial state will be `{}`.\n   * @property {Function} [Actions=()=>({})] - a function that creates actions, of the form\n   * `update => actions`.\n   * @property {Array<Function>} [services=[]] - an array of service functions, each of which\n   * should be `({ state, previousState, patch }) => patch?`.\n   * @property {Array<Function>} [effects=[]] - an array of effect functions, each of which\n   * should be `({ state, previousState, patch, update, actions }) => void`, with the function\n   * optionally calling `update` and/or `actions`.\n   */\n\n  /**\n   * Stream library. This works with `meiosis.simpleStream`, `flyd`, `m.stream`, or anything for\n   * which you provide either a function or an object with a `stream` function to create a stream. The\n   * function or object must also have a `scan` property. The returned stream must have a `map`\n   * method.\n   *\n   * @typedef {Object|Function} StreamLib\n   * @param {*} [value] - the stream's initial value.\n   * @property {Function} stream - the function to create a stream, if the stream library itself is\n   * not a function.\n   * @property {Function} scan - the stream library's `scan` function.\n   * @return {simpleStream} - the created stream.\n   */\n\n  /**\n   * Base helper to setup the Meiosis pattern. If you are using Mergerino, Function Patches, or Immer,\n   * use their respective `setup` function instead.\n   *\n   * Patch is merged in to the state by default. Services have access to the state, previous state,\n   * and patch, and can return a patch that further updates the state, reverts to the previous state,\n   * and so on. State changes by services are available to the next services in the list.\n   *\n   * After the services have run and the state has been updated, effects are executed and have the\n   * opportunity to trigger more updates.\n   *\n   * @async\n   * @function meiosis.common.setup\n   *\n   * @param {StreamLib} stream - the stream library. This works with `meiosis.simpleStream`, `flyd`,\n   * `m.stream`, or anything for which you provide either a function or an object with a `stream`\n   * function to create a stream. The function or object must also have a `scan` property. The\n   * returned stream must have a `map` method.\n   * @param {Function} accumulator - the accumulator function.\n   * @param {Function} combine - the function that combines an array of patches into one.\n   * @param {app} app - the app, with optional properties.\n   *\n   * @returns {Object} - `{ update, states, actions }`, where `update` and `states` are streams, and\n   * `actions` are the created actions.\n   */\n\n  function commonSetup(ref) {\n    var stream = ref.stream;\n    var accumulator = ref.accumulator;\n    var combine = ref.combine;\n    var app = ref.app;\n\n    if (!stream) {\n      throw new Error(\"No stream library was specified.\");\n    }\n\n    if (!accumulator) {\n      throw new Error(\"No accumulator function was specified.\");\n    }\n\n    if (!combine) {\n      throw new Error(\"No combine function was specified.\");\n    }\n\n    app = app || {};\n    var initial = app.initial;\n    var Actions = app.Actions;\n    var services = app.services;\n    var effects = app.effects;\n    initial = initial || {};\n    services = services || [];\n    effects = effects || [];\n\n    var singlePatch = function (patch) {\n      return Array.isArray(patch) ? combine(patch) : patch;\n    };\n\n    var accumulatorFn = function (state, patch) {\n      return patch ? accumulator(state, singlePatch(patch)) : state;\n    };\n\n    var createStream = typeof stream === \"function\" ? stream : stream.stream;\n    var scan = stream.scan;\n    var update = createStream();\n\n    var actions = (Actions || function () {\n      return {};\n    })(update);\n\n    var states = createStream(); // context is { state, patch, previousState }\n    // state is optionally updated by service patches; patch and previousState never change.\n\n    var runServices = function (context) {\n      var updatedContext = context;\n\n      for (var i = 0; i < services.length; i++) {\n        // a service should (optionally) return a patch\n        var servicePatch = services[i](updatedContext);\n        updatedContext.state = accumulatorFn(updatedContext.state, servicePatch);\n      }\n\n      return updatedContext;\n    };\n\n    var contexts = scan(function (context, patch) {\n      return runServices({\n        previousState: context.state,\n        state: accumulatorFn(context.state, patch),\n        patch: patch\n      });\n    }, runServices({\n      state: initial,\n      previousState: initial\n    }), update);\n    contexts.map(function (context) {\n      if (context.state !== states()) {\n        states(context.state);\n      }\n\n      effects.forEach(function (effect) {\n        effect(Object.assign(context, {\n          update: update,\n          actions: actions\n        }));\n      });\n    });\n    return {\n      update: update,\n      states: states,\n      actions: actions\n    };\n  }\n  /**\n   * Helper to setup the Meiosis pattern with [Mergerino](https://github.com/fuzetsu/mergerino).\n   *\n   * @async\n   * @function meiosis.mergerino.setup\n   *\n   * @param {StreamLib} stream - the stream library. This works with `meiosis.simpleStream`, `flyd`,\n   * `m.stream`, or anything for which you provide either a function or an object with a `stream`\n   * function to create a stream. The function or object must also have a `scan` property.\n   * The returned stream must have a `map` method.\n   * @param {Function} merge - the Mergerino `merge` function.\n   * @param {app} app - the app, with optional properties.\n   *\n   * @returns {Object} - `{ update, states, actions }`, where `update` and `states` are streams,\n   * and `actions` are the created actions.\n   */\n\n\n  function mergerinoSetup(ref) {\n    var stream = ref.stream;\n    var merge = ref.merge;\n    var app = ref.app;\n    return commonSetup({\n      stream: stream,\n      accumulator: merge,\n      combine: function (patches) {\n        return patches;\n      },\n      app: app\n    });\n  }\n\n  var pipe = function (fns) {\n    return function (args) {\n      return fns.reduce(function (arg, fn) {\n        return fn(arg);\n      }, args);\n    };\n  };\n  /**\n   * Helper to setup the Meiosis pattern with function patches.\n   *\n   * @async\n   * @function meiosis.functionPatches.setup\n   *\n   * @param {StreamLib} stream - the stream library. This works with `meiosis.simpleStream`, `flyd`,\n   * `m.stream`, or anything for which you provide either a function or an object with a `stream`\n   * function to create a stream. The function or object must also have a `scan` property.\n   * The returned stream must have a `map` method.\n   * @param {app} app - the app, with optional properties.\n   *\n   * @returns {Object} - `{ update, states, actions }`, where `update` and `states` are streams,\n   * and `actions` are the created actions.\n   */\n\n\n  function functionPatchesSetup(ref) {\n    var stream = ref.stream;\n    var app = ref.app;\n    return commonSetup({\n      stream: stream,\n      accumulator: function (x, f) {\n        return f(x);\n      },\n      combine: pipe,\n      app: app\n    });\n  }\n  /**\n   * Helper to setup the Meiosis pattern with [Immer](https://github.com/immerjs/immer).\n   *\n   * @async\n   * @function meiosis.immer.setup\n   *\n   * @param {StreamLib} stream - the stream library. This works with `meiosis.simpleStream`, `flyd`,\n   * `m.stream`, or anything for which you provide either a function or an object with a `stream`\n   * function to create a stream. The function or object must also have a `scan` property.\n   * The returned stream must have a `map` method.\n   * @param {Function} produce - the Immer `produce` function.\n   * @param {app} app - the app, with optional properties.\n   *\n   * @returns {Object} - `{ update, states, actions }`, where `update` and `states` are streams,\n   * and `actions` are the created actions.\n   */\n\n\n  function immerSetup(ref) {\n    var stream = ref.stream;\n    var produce = ref.produce;\n    var app = ref.app;\n    return commonSetup({\n      stream: stream,\n      accumulator: produce,\n      // can't use patches.reduce(produce, state) because that would send a third argument to produce\n      combine: function (patches) {\n        return function (state) {\n          return patches.reduce(function (result, patch) {\n            return produce(result, patch);\n          }, state);\n        };\n      },\n      app: app\n    });\n  }\n  /**\n   * Helper to setup the Meiosis pattern with [Preact](https://preactjs.com/).\n   *\n   * @function meiosis.preact.setup\n   *\n   * @param {preact.h} h - the Preact h function.\n   * @param {preact.Component} Component - the Preact Component class.\n   * @param {preact.Component} Root - your Root component, which receives `state`, `update`, and\n   * `actions`.\n   *\n   * @returns {preact.Component} - the top-level component to which you pass `states`, `update`,\n   * and `actions`.\n   */\n\n\n  function preactSetup(ref) {\n    var h = ref.h;\n    var Component = ref.Component;\n    var Root = ref.Root;\n\n    var App = /*@__PURE__*/function (Component) {\n      function App(props) {\n        Component.call(this, props);\n        this.state = props.states();\n        this.skippedFirst = false;\n      }\n\n      if (Component) App.__proto__ = Component;\n      App.prototype = Object.create(Component && Component.prototype);\n      App.prototype.constructor = App;\n\n      App.prototype.componentDidMount = function componentDidMount() {\n        var this$1 = this;\n        var setState = this.setState.bind(this);\n        this.props.states.map(function (state) {\n          if (this$1.skippedFirst) {\n            setState(state);\n          } else {\n            this$1.skippedFirst = true;\n          }\n        });\n      };\n\n      App.prototype.render = function render() {\n        var state = this.state;\n        var ref = this.props;\n        var update = ref.update;\n        var actions = ref.actions;\n        return h(Root, {\n          state: state,\n          update: update,\n          actions: actions\n        });\n      };\n\n      return App;\n    }(Component);\n\n    return App;\n  }\n  /**\n   * Helper to setup the Meiosis pattern with [React](https://reactjs.org/).\n   *\n   * @function meiosis.react.setup\n   *\n   * @param {React} React - the React instance.\n   * @param {React.Component} Root -  your Root component, which receives `state` and `actions`.\n   *\n   * @returns {React.Component} - the top-level component to which you pass `states` and `actions`.\n   */\n\n\n  function reactSetup(ref) {\n    var React = ref.React;\n    var Root = ref.Root;\n\n    var App = /*@__PURE__*/function (superclass) {\n      function App(props) {\n        superclass.call(this, props);\n        this.state = props.states();\n        this.skippedFirst = false;\n      }\n\n      if (superclass) App.__proto__ = superclass;\n      App.prototype = Object.create(superclass && superclass.prototype);\n      App.prototype.constructor = App;\n\n      App.prototype.componentDidMount = function componentDidMount() {\n        var this$1 = this;\n        var setState = this.setState.bind(this);\n        this.props.states.map(function (state) {\n          if (this$1.skippedFirst) {\n            setState(state);\n          } else {\n            this$1.skippedFirst = true;\n          }\n        });\n      };\n\n      App.prototype.render = function render() {\n        var state = this.state;\n        var ref = this.props;\n        var actions = ref.actions;\n        return React.createElement(Root, {\n          state: state,\n          actions: actions\n        });\n      };\n\n      return App;\n    }(React.Component);\n\n    return App;\n  }\n  /**\n   * A simple stream.\n   *\n   * @typedef {Function} simpleStream\n   * @param {*} [value] - emits a value onto the stream. When not specified, returns the\n   * stream's latest value.\n   * @property {Function} map - creates a new stream for which the values from the original stream\n   * are processed by the passed-in function and emitted onto the new stream.\n   */\n\n  /**\n   * Creates a stream.\n   * @function meiosis.simpleStream.stream\n   * @param {*} [initial] - the stream's initial value.\n   * @returns {simpleStream} the created stream.\n   */\n\n\n  var stream = function (initial) {\n    var mapFunctions = [];\n    var latestValue = initial;\n\n    var createdStream = function (value) {\n      if (value !== undefined) {\n        latestValue = value;\n\n        for (var i in mapFunctions) {\n          mapFunctions[i](value);\n        }\n      }\n\n      return latestValue;\n    };\n\n    createdStream.map = function (mapFunction) {\n      var newInitial = undefined;\n\n      if (latestValue !== undefined) {\n        newInitial = mapFunction(latestValue);\n      }\n\n      var newStream = stream(newInitial);\n      mapFunctions.push(function (value) {\n        newStream(mapFunction(value));\n      });\n      return newStream;\n    };\n\n    return createdStream;\n  };\n  /**\n   * Creates a new stream that starts with the initial value and, for each value arriving onto\n   * the source stream, emits the result of calling the accumulator function with the latest\n   * result and the source stream value.\n   *\n   * @function meiosis.simpleStream.scan\n   *\n   * @param {Function} accumulator - a two-parameter function, the result of which is emitted\n   * onto the returned stream.\n   * @param {*} initial - the initial value for the returned stream.\n   * @param {simpleStream} sourceStream - the source stream from which values are processed by the\n   * accumulator function.\n   * @returns {simpleStream} the created stream.\n   */\n\n\n  var scan = function (accumulator, initial, sourceStream) {\n    var newStream = stream(initial);\n    var accumulated = initial;\n    sourceStream.map(function (value) {\n      accumulated = accumulator(accumulated, value);\n      newStream(accumulated);\n    });\n    return newStream;\n  };\n\n  var simpleStream = {\n    stream: stream,\n    scan: scan\n  };\n  var index = {\n    common: {\n      setup: commonSetup\n    },\n    mergerino: {\n      setup: mergerinoSetup\n    },\n    functionPatches: {\n      setup: functionPatchesSetup\n    },\n    immer: {\n      setup: immerSetup\n    },\n    preact: {\n      setup: preactSetup\n    },\n    react: {\n      setup: reactSetup\n    },\n    simpleStream: simpleStream\n  };\n  return index;\n});\n\n//# sourceURL=webpack:////Users/freddy/fd/git/foxdonut/meiosis/helpers/setup/dist/meiosis-setup.js?");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return H; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return I; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidElement\", function() { return l; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return m; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return L; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return M; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toChildArray\", function() { return x; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_unmount\", function() { return D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return n; });\nvar n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function v(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var i,t=arguments,o={};for(i in l)\"key\"!==i&&\"ref\"!==i&&(o[i]=l[i]);if(arguments.length>3)for(u=[u],i=3;i<arguments.length;i++)u.push(t[i]);if(null!=u&&(o.children=u),\"function\"==typeof n&&null!=n.defaultProps)for(i in n.defaultProps)void 0===o[i]&&(o[i]=n.defaultProps[i]);return p(n,o,l&&l.key,l&&l.ref)}function p(l,u,i,t){var o={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0};return n.vnode&&n.vnode(o),o}function y(){return{}}function d(n){return n.children}function m(n,l){this.props=n,this.context=l}function w(n,l){if(null==l)return n.__?w(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?w(n):null}function g(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return g(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!i++||o!==n.debounceRendering)&&((o=n.debounceRendering)||t)(_)}function _(){for(var n;i=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],i=A(r,t,a({},t),l.__n,void 0!==r.ownerSVGElement,null,u,null==o?w(t):o),T(u,t),i!=o&&g(t)))})}function b(n,l,u,i,t,o,r,f,s){var a,h,p,y,d,m,g,k=u&&u.__k||c,_=k.length;if(f==e&&(f=null!=o?o[0]:_?w(u,0):null),a=0,l.__k=x(l.__k,function(u){if(null!=u){if(u.__=l,u.__b=l.__b+1,null===(p=k[a])||p&&u.key==p.key&&u.type===p.type)k[a]=void 0;else for(h=0;h<_;h++){if((p=k[h])&&u.key==p.key&&u.type===p.type){k[h]=void 0;break}p=null}if(y=A(n,u,p=p||e,i,t,o,r,f,s),(h=u.ref)&&p.ref!=h&&(g||(g=[]),p.ref&&g.push(p.ref,null,u),g.push(h,u.__c||y,u)),null!=y){var c;if(null==m&&(m=y),void 0!==u.__d)c=u.__d,u.__d=void 0;else if(o==p||y!=f||null==y.parentNode){n:if(null==f||f.parentNode!==n)n.appendChild(y),c=null;else{for(d=f,h=0;(d=d.nextSibling)&&h<_;h+=2)if(d==y)break n;n.insertBefore(y,f),c=f}\"option\"==l.type&&(n.value=\"\")}f=void 0!==c?c:y.nextSibling,\"function\"==typeof l.type&&(l.__d=f)}else f&&p.__e==f&&f.parentNode!=n&&(f=w(p))}return a++,u}),l.__e=m,null!=o&&\"function\"!=typeof l.type)for(a=o.length;a--;)null!=o[a]&&v(o[a]);for(a=_;a--;)null!=k[a]&&D(k[a],k[a]);if(g)for(a=0;a<g.length;a++)j(g[a],g[++a],g[++a])}function x(n,l,u){if(null==u&&(u=[]),null==n||\"boolean\"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var i=0;i<n.length;i++)x(n[i],l,u);else u.push(l?l(\"string\"==typeof n||\"number\"==typeof n?p(null,n,null,null):null!=n.__e||null!=n.__c?p(n.type,n.props,n.key,null):n):n);return u}function P(n,l,u,i,t){var o;for(o in u)o in l||N(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"value\"===o||\"checked\"===o||u[o]===l[o]||N(n,o,l[o],u[o],i)}function C(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=\"number\"==typeof u&&!1===s.test(l)?u+\"px\":null==u?\"\":u}function N(n,l,u,i,t){var o,r,f,e,c;if(t?\"className\"===l&&(l=\"class\"):\"class\"===l&&(l=\"className\"),\"key\"===l||\"children\"===l);else if(\"style\"===l)if(o=n.style,\"string\"==typeof u)o.cssText=u;else{if(\"string\"==typeof i&&(o.cssText=\"\",i=null),i)for(r in i)u&&r in u||C(o,r,\"\");if(u)for(f in u)i&&u[f]===i[f]||C(o,f,u[f])}else\"o\"===l[0]&&\"n\"===l[1]?(e=l!==(l=l.replace(/Capture$/,\"\")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(i||n.addEventListener(l,z,e),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,z,e)):\"list\"!==l&&\"tagName\"!==l&&\"form\"!==l&&\"type\"!==l&&\"size\"!==l&&!t&&l in n?n[l]=null==u?\"\":u:\"function\"!=typeof u&&\"dangerouslySetInnerHTML\"!==l&&(l!==(l=l.replace(/^xlink:?/,\"\"))?null==u||!1===u?n.removeAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase()):n.setAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function z(l){this.l[l.type](n.event?n.event(l):l)}function A(l,u,i,t,o,r,f,e,c){var s,v,h,p,y,w,g,k,_,x,P=u.type;if(void 0!==u.constructor)return null;(s=n.__b)&&s(u);try{n:if(\"function\"==typeof P){if(k=u.props,_=(s=P.contextType)&&t[s.__c],x=s?_?_.props.value:s.__:t,i.__c?g=(v=u.__c=i.__c).__=v.__E:(\"prototype\"in P&&P.prototype.render?u.__c=v=new P(k,x):(u.__c=v=new m(k,x),v.constructor=P,v.render=E),_&&_.sub(v),v.props=k,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=a({},v.__s)),a(v.__s,P.getDerivedStateFromProps(k,v.__s))),p=v.props,y=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&k!==p&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(k,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(k,v.__s,x)){for(v.props=k,v.state=v.__s,v.__d=!1,v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v),s=0;s<u.__k.length;s++)u.__k[s]&&(u.__k[s].__=u);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(k,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(p,y,w)})}v.context=x,v.props=k,v.state=v.__s,(s=n.__r)&&s(u),v.__d=!1,v.__v=u,v.__P=l,s=v.render(v.props,v.state,v.context),u.__k=null!=s&&s.type==d&&null==s.key?s.props.children:Array.isArray(s)?s:[s],null!=v.getChildContext&&(t=a(a({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(p,y)),b(l,u,i,t,o,r,f,e,c),v.base=u.__e,v.__h.length&&f.push(v),g&&(v.__E=v.__=null),v.__e=!1}else u.__e=$(i.__e,u,i,t,o,r,f,c);(s=n.diffed)&&s(u)}catch(l){n.__e(l,u,i)}return u.__e}function T(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function $(n,l,u,i,t,o,r,f){var s,a,v,h,p,y=u.props,d=l.props;if(t=\"svg\"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS(\"http://www.w3.org/2000/svg\",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null}if(null===l.type)y!==d&&n.data!=d&&(n.data=d);else if(l!==u){if(null!=o&&(o=c.slice.call(n.childNodes)),v=(y=u.props||e).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!f){if(y===e)for(y={},p=0;p<n.attributes.length;p++)y[n.attributes[p].name]=n.attributes[p].value;(h||v)&&(h&&v&&h.__html==v.__html||(n.innerHTML=h&&h.__html||\"\"))}P(n,d,y,t,f),l.__k=l.props.children,h||b(n,l,u,i,\"foreignObject\"!==l.type&&t,o,r,e,f),f||(\"value\"in d&&void 0!==d.value&&d.value!==n.value&&(n.value=null==d.value?\"\":d.value),\"checked\"in d&&void 0!==d.checked&&d.checked!==n.checked&&(n.checked=d.checked))}return n}function j(l,u,i){try{\"function\"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function D(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||j(t,null,u)),i||\"function\"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&D(t[r],u,i);null!=o&&v(o)}function E(n,l,u){return this.constructor(n,u)}function H(l,u,i){var t,o,f;n.__&&n.__(l,u),o=(t=i===r)?null:i&&i.__k||u.__k,l=h(d,null,[l]),f=[],A(u,(t?u:i||u).__k=l,o||e,e,void 0!==u.ownerSVGElement,i&&!t?[i]:o?null:c.slice.call(u.childNodes),f,i||e,t),T(f,l)}function I(n,l){H(n,l,r)}function L(n,l){return l=a(a({},n.props),l),arguments.length>2&&(l.children=c.slice.call(arguments,2)),p(n.type,l,l.key||n.key,l.ref||n.ref)}function M(n){var l={},u={__c:\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var i,t=this;return this.getChildContext||(i=[],this.getChildContext=function(){return l[u.__c]=t,l},this.shouldComponentUpdate=function(l){n.value!==l.value&&i.some(function(n){n.context=l.value,k(n)})},this.sub=function(n){i.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){i.splice(i.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u}n={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},m.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(u,this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},m.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},m.prototype.render=d,u=[],i=0,t=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,r=e,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack:///./node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./src/index.jsx":
/*!***********************!*\
  !*** ./src/index.jsx ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../dist/meiosis-setup */ \"../../dist/meiosis-setup.js\");\n/* harmony import */ var _dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar Root = function Root(_ref) {\n  var state = _ref.state,\n      update = _ref.update,\n      actions = _ref.actions;\n  return Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", null, Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", null, \"Counter: \", state.counter), Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", null, \"Greeting: \", state.greeting), Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", null, Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"button\", {\n    onClick: function onClick() {\n      return actions.increment();\n    }\n  }, \"Increment\")), Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", null, Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"button\", {\n    onClick: function onClick() {\n      return update(function (state) {\n        return _objectSpread({}, state, {\n          greeting: \"Hello\"\n        });\n      });\n    }\n  }, \"Say Hello\")));\n};\n\nvar App = _dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0___default.a.preact.setup({\n  h: preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"],\n  Component: preact__WEBPACK_IMPORTED_MODULE_1__[\"Component\"],\n  Root: Root\n});\n\nvar _meiosis$functionPatc = _dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0___default.a.functionPatches.setup({\n  stream: _dist_meiosis_setup__WEBPACK_IMPORTED_MODULE_0___default.a.simpleStream,\n  app: {\n    initial: {\n      counter: 0\n    },\n    Actions: function Actions(update) {\n      return {\n        increment: function increment() {\n          return update(function (state) {\n            return _objectSpread({}, state, {\n              counter: state.counter + 1\n            });\n          });\n        }\n      };\n    }\n  }\n}),\n    states = _meiosis$functionPatc.states,\n    update = _meiosis$functionPatc.update,\n    actions = _meiosis$functionPatc.actions;\n\nvar element = document.getElementById(\"app\");\nObject(preact__WEBPACK_IMPORTED_MODULE_1__[\"render\"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(App, {\n  states: states,\n  update: update,\n  actions: actions\n}), element);\n\n//# sourceURL=webpack:///./src/index.jsx?");

/***/ })

/******/ });